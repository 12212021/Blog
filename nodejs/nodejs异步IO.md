### 操作系统OS IO读取方式

#### 阻塞IO
操作系统内核OS线程采用read读取文件内容，IO线程会读取相关数据，待数据读取完毕拷贝到内存的时候
os线程使用这份数据继续工作，在io线程读取数据期间，os线程一直在等待数据返回，处于阻塞情况。

#### 非阻塞IO（暂时不是很理解）
- select
- poll
- epoll

### nodejs对于异步IO的实现方式
nodejs采用IO线程池的方式来模拟异步的IO，js发起异步IO调用，node会将这些参数封装成一个请求对象，
将这个请求对象放到IO线程池中等待执行。当IO线程池中有可用的IO线程时，分配一个IO线程给请求对象，待数据读取
完成之后，将数据挂载到*请求对象*上，同时通知IOCP（IO线程池的管理员），归还相关的IO线程。时间循环队列从*IO观察者*中
获取到可用的请求对象，从请求对象中拿出回调函数执行。

![image.png](https://i.loli.net/2020/03/30/TNRYPfy6bvAW94G.png)

#### 事件循环机制
类似于一个while(true)的循环机制，每次循环成为一个Tick，在每一个Tick中，主线程会查看是否有相关的事件需要处理，
如果有的话就取出相关的回调函数执行。

#### 观察者
事件循环机制如何判断是否有事件需要处理呢？通常的方式是询问相关的观察者（idle观察者、IO观察者等），观察者通过观察请求对象的
相关状态能够准确地知道当前是否有相关的事件需要处理。

#### 请求对象
js在调用异步IO API时，相关参数、回调函数等相关的内容会被node封装成一个请求对象，改请求对象会被推入到线程池中等待被执行的机会

### 非IO的nodejs异步API

#### setTimeout、setInterval
不精确，创建的定时器会被插入到定时器观察者内部维护的一棵红黑树中，每次Tick执行的时候，会查询整个
定时器观察者内部的红黑树，执行超过定时时间的事件。

#### setImmediate、process.nextTick
主要的作用是在下一次Tick中被执行，是setTimeout(cb, 0)的一种替代，性能比较强，会将回调函数放在队列中（下一次必定执行的队列）
时间复杂度是O(1)，setImmediate和process.nextTick的作用差不多，但是process.nextTick的优先级高于setImmediate。


