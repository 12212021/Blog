#### vim的基本操作和配置

非insert模式下
- G 快速移动到文档的底部（常用语查看日志）
- gg 快速移动到文件的顶部
- 0 快速移动到行首
- $ 快速移动到行尾
- :13 移动到第13行
- ZZ 光标放置到屏幕中间
- dd 剪切本行
- yy 复制本行
- u 撤销（undo缩写，撤销）
- p 粘贴（paste缩写）
- 在mac系统下可以option + 点击快速移动到想要移动的位置
- q! 不保存编辑的内容
- wq 写入编辑的内容
- set paste 进入paste模式，i键编辑，粘贴文本不会发生缩进错乱的问题
- set nopaste 退出paste模式

insert模式下
- i 在当前光标下面进行编辑
- o 快速进入insert模式，并定位到下一行进行编辑
- esc退出insert模式


#### git commit信息指南(AngularJS 开发者规范)

commit message的组成结构如下
- header(required)
  - type(required)
  - suject(required)
  - scope(optional)
- body(optional)
- footer(optional)


type: 
- feat:新功能
- fix:bug修复
- docs:仅仅修改文档
- style:修改格式（空格、格式化、分号等），对代码的运行没有影响
- refactor:重构代码（既不是修bug，也不是开发新功能）
- build:（构建流程、外部依赖变更，如升级npm包，更改webpack配置）
- perf:性能优化
- test:测试相关
- chore:对构建过程或辅助工具和库（如文档生成）的更改
- ci:ci工具的修改


scope：可以指定提交修改的影响范围，修改超过单个scope的时候，可以用*指定


Subject：是总结性的提交记录，长度在50字以内，有一下规范
- 用动词开头，以第一人称来表述，如change代替changed、changes
- 第一个字母要小写
- 结尾不加分号


Body：是对commit信息的详细描述，可以分为多行，应该说明修改的原因和**更改前后的行为对比**


footer：
- 不兼容的更改，通常用BREAKING CHANGE: 开头，后面跟着变动信息和迁移方案
- 关闭github的Issue （Close #254 #233）


example：
```bash
feat($browser): onUrlChange event (popstate/hashchange/polling)

Added new event to $browser:
- forward popstate event if available
- forward hashchange event if popstate not available
- do polling when neither popstate nor hashchange available

Breaks $browser.onHashChange, which was removed (use onUrlChange instead)
```

```bash
fix($compile): couple of unit tests for IE9

Older IEs serialize html uppercased, but IE9 does not...
Would be better to expect case insensitive, unfortunately jasmine does
not allow to user regexps for throw expectations.

Closes #392
Breaks foo.bar api, foo.baz should be used instead
```

```bash
style($location): add couple of missing semi colons
```


工具：Commitizen可以规范git commit的提交记录



#### DOM中的盒模型

offsetWidth、offsetHeight：(width + padding + border)，当element的display为block的时候

clientWidth、clientHeight：(width + padding)，不包括border和scroll bar

scrollWidth、scrollHeight：盒子的实际长度或者宽度，一般而言，当overflow属性为auto的时候，盒子是可以滚动的，这个两个属性包括被隐藏的那一部分，是盒子的实际宽度和高度
![image.png](https://i.loli.net/2020/09/23/6IyagvAcTMCWh3Y.png)


offsetParent：满足下面一个条件的祖先元素
- 具有css定位（position为absolute、relative、fixed、sticky）
- <td> <th> <table>中一个
- <body>

offsetLeft、offsetTop：表示DOM盒模型（offsetHeight、offsetWidth尺寸）和祖先元素的距离信息，**这个是相对距离，如果父元素能够滚动的话，不会随着父元素的滚动而发生变化**

scrollLeft、scrollTop：针对能够滚动的元素而言的（**设置overflow: auto属性的元素，而不是它的子元素**），描述的是元素滚动了多少

clientLeft、clientTop：描述的是border，**如果浏览器的滚动条在左侧的话，clientLeft包含滚动条宽度**


```js
/* 
前提：父元素的定位是relative，子元素不包含margin


判断一个可滚动的元素内子元素是否在容器的可视窗口内？
1、子元素整个盒子都进入容器的视口内
2、子元素有一丝空间进入容器视口内部
3、子元素整个盒子都离开容器的视口内
4、子元素有一丝空间离开容器视口内部 

变量只有一个： father.scrollTop
常量有三个： child.offsetTop  child.offsetHeight  father.offsetHeight
*/




/* 
子元素整个盒子都进入容器的视口内
临界条件: father.scrollTop + father.offsetHeight = child.offsetTop + child.offsetHeight
再向上滚动，scrollTop值增大，child元素就可以视为完全进入了

故条件为father.scrollTop + father.offsetHeight > child.offsetTop + child.offsetHeight

*/
function isChildTotalIn(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const fatherHeight = fatherDOM.offsetHeight;
    const childOffsetTop = child.offsetTop;
    const childHeight = child.offsetHeight;
    return fatherScrollTop > childOffsetTop + childHeight - fatherHeight;
}





/* 
子元素有一丝空间进入到父容器的视口
临界条件: father.scrollTop + father.offsetHeight = child.offsetTop
再向上滚动即认为子元素有部分区域进入视口了

father.scrollTop > child.offsetTop - father.offsetHeight
*/

function isChildIn(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const fatherHeight = fatherDOM.offsetHeight;
    return fatherScrollTop > child.offsetTop - fatherHeight;
}



/* 
子元素整个盒子都离开父容器的视口
临界条件: father.scrollTop = child.offsetTop + child.offsetHeight


father.scrollTop > child.offsetTop + child.offsetHeight
*/

function isChildTotalOut(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const childOffsetTop = child.offsetTop;
    const childHeight = child.offsetHeight;
    return fatherScrollTop > childOffsetTop + childHeight;
}



/* 
子元素整个盒子都进入容器的视口内
临界条件: father.scrollTop = child.offsetTop

故条件为father.scrollTop > child.offsetTop

*/
function isChildOut(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const childOffsetTop = child.offsetTop;
    return fatherScrollTop > childOffsetTop;
}
```