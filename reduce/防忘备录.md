#### vim的基本操作和配置

非insert模式下
- G 快速移动到文档的底部（常用语查看日志）
- gg 快速移动到文件的顶部
- 0 快速移动到行首
- $ 快速移动到行尾
- :13 移动到第13行
- ZZ 光标放置到屏幕中间
- dd 剪切本行
- yy 复制本行
- u 撤销（undo缩写，撤销）
- p 粘贴（paste缩写）
- 在mac系统下可以option + 点击快速移动到想要移动的位置
- q! 不保存编辑的内容
- wq 写入编辑的内容
- set paste 进入paste模式，i键编辑，粘贴文本不会发生缩进错乱的问题
- set nopaste 退出paste模式

insert模式下
- i 在当前光标下面进行编辑
- o 快速进入insert模式，并定位到下一行进行编辑
- esc退出insert模式


#### git commit信息指南(AngularJS 开发者规范)

commit message的组成结构如下
- header(required)
  - type(required)
  - suject(required)
  - scope(optional)
- body(optional)
- footer(optional)


type:
- feat:新功能
- fix:bug修复
- docs:仅仅修改文档
- style:修改格式（空格、格式化、分号等），对代码的运行没有影响
- refactor:重构代码（既不是修bug，也不是开发新功能）
- build:（构建流程、外部依赖变更，如升级npm包，更改webpack配置）
- perf:性能优化
- test:测试相关
- chore:对构建过程或辅助工具和库（如文档生成）的更改
- ci:ci工具的修改


scope：可以指定提交修改的影响范围，修改超过单个scope的时候，可以用*指定


Subject：是总结性的提交记录，长度在50字以内，有一下规范
- 用动词开头，以第一人称来表述，如change代替changed、changes
- 第一个字母要小写
- 结尾不加分号


Body：是对commit信息的详细描述，可以分为多行，应该说明修改的原因和**更改前后的行为对比**


footer：
- 不兼容的更改，通常用BREAKING CHANGE: 开头，后面跟着变动信息和迁移方案
- 关闭github的Issue （Close #254 #233）


example：
```bash
feat($browser): onUrlChange event (popstate/hashchange/polling)

Added new event to $browser:
- forward popstate event if available
- forward hashchange event if popstate not available
- do polling when neither popstate nor hashchange available

Breaks $browser.onHashChange, which was removed (use onUrlChange instead)
```

```bash
fix($compile): couple of unit tests for IE9

Older IEs serialize html uppercased, but IE9 does not...
Would be better to expect case insensitive, unfortunately jasmine does
not allow to user regexps for throw expectations.

Closes #392
Breaks foo.bar api, foo.baz should be used instead
```

```bash
style($location): add couple of missing semi colons
```


工具：Commitizen可以规范git commit的提交记录



#### DOM中的盒模型

offsetWidth、offsetHeight：(width + padding + border + 滚动条)
偏移尺寸，含义是：包含元素在屏幕上占据的视觉空间

clientWidth、clientHeight：(width + padding)，不包括border和scroll bar
客户尺寸：含义是：包含元素的内容和内边距（padding）占据的内容大小

scrollWidth、scrollHeight：盒子的实际长度或者宽度，一般而言，当overflow属性为auto的时候，盒子是可以滚动的，这个两个属性包括被隐藏的那一部分，是盒子的实际宽度和高度
![image.png](https://i.loli.net/2020/09/23/6IyagvAcTMCWh3Y.png)

getBoundingClientRect()函数返回一个DOMRect对象，指出了元素相对于视口的位置信息


offsetParent：满足下面一个条件的祖先元素
- 具有css定位（position为absolute、relative、fixed、sticky）
- <td> <th> <table>中一个
- <body>

offsetLeft、offsetTop：表示DOM盒模型（offsetHeight、offsetWidth尺寸）和offsetParent的距离信息，**这个是相对距离，如果父元素能够滚动的话，不会随着父元素的滚动而发生变化**

scrollLeft、scrollTop：针对能够滚动的元素而言的（**设置overflow: auto属性的元素，而不是它的子元素**），描述的是元素滚动了多少

clientLeft、clientTop：描述的是border，**如果浏览器的滚动条在左侧的话，clientLeft包含滚动条宽度**


```js
/*
前提：父元素的定位是relative，子元素不包含margin


判断一个可滚动的元素内子元素是否在容器的可视窗口内？
1、子元素整个盒子都进入容器的视口内
2、子元素有一丝空间进入容器视口内部
3、子元素整个盒子都离开容器的视口内
4、子元素有一丝空间离开容器视口内部

变量只有一个： father.scrollTop
常量有三个： child.offsetTop  child.offsetHeight  father.offsetHeight
*/




/*
子元素整个盒子都进入容器的视口内
临界条件: father.scrollTop + father.offsetHeight = child.offsetTop + child.offsetHeight
再向上滚动，scrollTop值增大，child元素就可以视为完全进入了

故条件为father.scrollTop + father.offsetHeight > child.offsetTop + child.offsetHeight

*/
function isChildTotalIn(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const fatherHeight = fatherDOM.offsetHeight;
    const childOffsetTop = child.offsetTop;
    const childHeight = child.offsetHeight;
    return fatherScrollTop > childOffsetTop + childHeight - fatherHeight;
}





/*
子元素有一丝空间进入到父容器的视口
临界条件: father.scrollTop + father.offsetHeight = child.offsetTop
再向上滚动即认为子元素有部分区域进入视口了

father.scrollTop > child.offsetTop - father.offsetHeight
*/

function isChildIn(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const fatherHeight = fatherDOM.offsetHeight;
    return fatherScrollTop > child.offsetTop - fatherHeight;
}



/*
子元素整个盒子都离开父容器的视口
临界条件: father.scrollTop = child.offsetTop + child.offsetHeight


father.scrollTop > child.offsetTop + child.offsetHeight
*/

function isChildTotalOut(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const childOffsetTop = child.offsetTop;
    const childHeight = child.offsetHeight;
    return fatherScrollTop > childOffsetTop + childHeight;
}



/*
子元素整个盒子都进入容器的视口内
临界条件: father.scrollTop = child.offsetTop

故条件为father.scrollTop > child.offsetTop

*/
function isChildOut(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const childOffsetTop = child.offsetTop;
    return fatherScrollTop > childOffsetTop;
}
```



#### BFC
BFC表示一块dom区域，影响block box的布局，floats元素和其他元素的交互，当存在下面的属性的时候，BFC context formatting发生
- root element(<html>)
- floats属性不是none
- position为fixed或者absolute
- display:inline-block
- display:table-cell
- display:table-caption
- display:flow-root 这个属性没有任何额外的效果，就是让dom表现为BFC context formatting
- overflow的属性不是visible或者clip
- display: flex的直接子元素
- display: grid的直接子元素


BFC context formatting的作用如下
- 当内部含有float的元素的时候，防止父元素的高度塌陷
- 当block表现为BFC的时候，不会跟float重叠
- 可以避免margin collapsing

具体的demo参考
./css/backup/bfc.html



#### GET、POST请求区别
- get、post在浏览器点击回退都会请求，但是get请求一般是无害的
- get请求的url地址可以被收藏，但是post不可以
- get请求会被浏览器缓存，而post不会，除非被手动设置
- get请求的参数会被完整的保存在浏览器的历史记录里面，post不会
- get、post请求长度http协议并没有限制，get请求的的url长度可能会被浏览器或者服务器端截断，post不会
- get请求参数直接放在url里面，不适合敏感参数的传递，post请求放在Request Body里面




#### 浏览器捕获和冒泡流程
![image.png](https://i.loli.net/2020/11/30/xcil8StjeuPGpTE.png)

window -> window

body -> document.body

html -> document.docmentElement


#### 前端页面的错误监控

- 运行时错误
  - 通过try-catch的方式来捕获错误
  - 通过window.onerror的方式来捕获错误
- 资源加载错误
  - 资源加载错误不会冒泡，不能在冒泡阶段捕获错误，但是可以在捕获阶段监听错误事件
  - Object.onerror事件，在加载图片或者文件的时候发生错误，执行该函数
  - window.addEventListener('Error', function() {}, true) 在捕获阶段可监听错误

上报错误的方式
- ajax(不是主流方式)
- (new Image()).src = 'http://baidu.com/error?name=yu'（简单便捷，不依赖其他库，可以快速上传）


#### dom响应事件中的this
dom中绑定事件有两种方式*addEventListener*和*dom.onclick=function*两种方式
```js
const btnDOM = document.querySelector('.btn');
btnDOM.addEventListener('click', function (e) {
    console.log(this); // btnDOM对象
});
btnDOM.onclick = function (e) {
    console.log(this); // btnDOM对象
};
// 如果绑定的函数是箭头函数，在严格模式下，this是undefined，否则为window（在全局环境下）
// 因为箭头函数没有自己的this，它的this指向了上层函数或者脚本（模块）的this

```


#### html自闭合标签
1.现行html5版本，空标签（void element）br、input可以采用如下两种写法`<input> <input />`对于html5而言，二者没有区别

2.对于外部标签（foreign elements）而言，右斜杠标识了改元素自闭合

3.void elements（area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr）

4.foreign elements（Elements from the MathML namespace and the SVG namespace.）

5.xhtml（严格语法）要求空标签必须自闭合（右斜杠），html5兼容xhtml写法，但是不强制要求自闭合



#### chrome切换tab触发钩子函数
当前时间节点（2021-2-3），按照caniuse.com的查阅，visibilitychange事件在safari上不冒泡，只能通过document来绑定，不能通过window来绑定
```js
document.addEventListener('visibilitychange', function () {
    if (document.visibilityState === 'visible') {
        console.log('show', Date.now());
    } else if (document.visibilityState === 'hidden') {
        console.log('hidden', Date.now());
    }
});
```



#### typeof instanceof以及类型判断

##### typeof
```js
typeof 123; // number
typeof '123' // string
typeof true // boolean
typeof Symbol(2) // symbol
typeof undefined // undefined
typeof (() => 2) // function
typeof [1,2,3] // object
typeof {a:1} // object
typeof null // object
```
总结：
- 对于一些基础类型（number、string、boolean、symbol、undefined），typeof能直接返回其类型
- 对于引用类型，除了函数能返回是函数类型，Array、对象字面量都返回object
- 对于null，返回object
- typeof操作符对于一些基础类型的判断是准确的


##### instanceof
```js
[1,2,3] instanceof Array // true
[1,2,3] instanceof Object // true
(() => 2) instanceof Function // true
(() => 2) instanceof Object // true
null instanceof Object // false\

// 自定义的对象
function Person() {
    this.name = 'yuchi';
    this.age = 12;
}
const p = new Person();
p instanceof Person; // true
// __proto__是每一个对象都存在的一个属性，而prototype是函数才存在属性
// __proto__没有明确的规范，一般用Object.getPrototype()函数来代替
```
总结：
- instanceof主要用于判断一个对象是不是另一个对象(构造函数)的实例
- 运行原理在于，判断左侧对象的__proto__属性是不是指向构造函数的prototype属性（可以向上，所以[1,2,3]也是Object的实例）


##### 类型判断
- 判断一个对象是不是Array，最简单的方式是Array.isArray()函数
- 通过上面的instanceof操作符也可以判断
- 通过Object.prototype.toString来判断类型，实例如下

```js
function whichType(obj) {
    const typeString = Object.prototype.toString.call(obj);
    switch (typeString) {
        case '[object Boolean]':
            return 'boolean';
        case '[object Number]':
            return 'number';
        case '[object String]':
            return 'string';
        case '[object Symbol]':
            return 'symbol';
        case '[object Undefined]':
            return 'undefined';
        case '[object Array]':
            return 'array';
        case '[object Null]':
            return 'null';
        case '[object Function]':
            return 'function';
        case '[object Object]':
            return 'object';
        case '[object Math]':
            return 'math';
        case '[object Date]':
            return 'date';
    }
}
```



#### XHR请求跨域

##### 概念
- 跨源安全策略：默认情况下，XHR只能访问和发起请求的页面再同一个域内的资源，为了限制脚本的恶意行为
- 非跨域访问：同一协议（http、https）；同一端口；同一域
- CORS（跨域资源共享）：基于HTTP头机制，服务器允许浏览器访问非自己域名下资源

##### 为什么会有CORS机制
浏览器启用跨源安全策略，主要是为了防止脚本的恶意行为，但是也需要提供一种机制来合理地访问跨域资源

##### 如何利用CORS跨域访问资源
1. xhr天然支持CORS跨域访问，访问时用绝对路径（http://example.com），如果需要携带cookie，可设置**withCredentials=true**
2. 对于simple请求而言，浏览器会在http头增加**Origin: www.baidu.com**，标识请求来源
3. 服务器若允许该origin的访问，返回**Access-Control-Allow-Origin: http:www.baidu.com**，浏览器会将返回交给xhr
4. 对于非simple请求，浏览器会发送preflighted请求
    - Origin:标识请求来源
    - Access-Control-Request-Method:标识xhr希望使用的请求方法
    - Access-COntrol-Request-Headers:标识xhr希望使用的自定义头部（用逗号进行分隔）
5.浏览器接收到请求后，会返回如下的请求头
    - Access-Control-Allow-Origin:允许请求源请求
    - Access-Control-Allow-Methods:允许的xhr跨域请求的方法
    - Access-Control-Allow-Headers:允许xhr跨域请求使用的自定义头
    - Access-Control-Max-Age: 1728000 标识preflighted请求能够缓存的时间，也就是说preflighted请求一般而言**一段时间内仅发送一次**
6.如果浏览器xhr请求携带了cookie但是服务端没有返回**Access-Control-Allow-Credentials: true**，则浏览器不会将返回交给xhr对象

##### simple request
满足如下条件的请求则可以视为simple request
- 请求方法为（GET、POST、HEAD）方法中的一种
- 除了浏览器自动设置的HTTP请求头外，只有（Accept、Accept-Language、Content-Language、Content-Type）能被手动设置
- 请求中没有使用ReadableStream对象
-  XMLHttpRequest.upload上没有注册事件处理函数


##### 代替性的跨源访问技术

图片探测技术，单向通信，可以向服务发送一些数据，但是收不到服务器返回的数据
```js
const imgDOM = new Image();
// 通过load和error函数能之后服务器处理完毕
imgDOM.onload = imgDOM.onerror = function() {
    console.log('done')
}

const url = 'http://baidu.com?from=http://zhihu.com&username=yuchi'
imgDOM.src = encodeURI(url);
```


JSONP技术：JSONP看起来和JSON一样，只是会被包裹在回调函数中`callback({"name": "yuchi"})`
```js
function handleResponse(response) {
    /**
     * 处理返回请求
     */
}

let script = document.createElement('script');
script.src = encodeURI('http://baid.com?callback=handleResponse');
document.body.insertBefore(script, document.body.firstChild);
/**
 * 这里是利用了script请求可以跨域的特性
 * 返回的js文件应该只有一句 handleResponse(data)
 */
```
