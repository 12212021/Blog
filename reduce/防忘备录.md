#### vim的基本操作和配置

非insert模式下
- G 快速移动到文档的底部（常用语查看日志）
- gg 快速移动到文件的顶部
- 0 快速移动到行首
- $ 快速移动到行尾
- :13 移动到第13行
- ZZ 光标放置到屏幕中间
- dd 剪切本行
- yy 复制本行
- u 撤销（undo缩写，撤销）
- p 粘贴（paste缩写）
- 在mac系统下可以option + 点击快速移动到想要移动的位置
- q! 不保存编辑的内容
- wq 写入编辑的内容
- set paste 进入paste模式，i键编辑，粘贴文本不会发生缩进错乱的问题
- set nopaste 退出paste模式

insert模式下
- i 在当前光标下面进行编辑
- o 快速进入insert模式，并定位到下一行进行编辑
- esc退出insert模式


#### git commit信息指南(AngularJS 开发者规范)

commit message的组成结构如下
- header(required)
  - type(required)
  - suject(required)
  - scope(optional)
- body(optional)
- footer(optional)


type:
- feat:新功能
- fix:bug修复
- docs:仅仅修改文档
- style:修改格式（空格、格式化、分号等），对代码的运行没有影响
- refactor:重构代码（既不是修bug，也不是开发新功能）
- build:（构建流程、外部依赖变更，如升级npm包，更改webpack配置）
- perf:性能优化
- test:测试相关
- chore:对构建过程或辅助工具和库（如文档生成）的更改
- ci:ci工具的修改


scope：可以指定提交修改的影响范围，修改超过单个scope的时候，可以用*指定


Subject：是总结性的提交记录，长度在50字以内，有一下规范
- 用动词开头，以第一人称来表述，如change代替changed、changes
- 第一个字母要小写
- 结尾不加分号


Body：是对commit信息的详细描述，可以分为多行，应该说明修改的原因和**更改前后的行为对比**


footer：
- 不兼容的更改，通常用BREAKING CHANGE: 开头，后面跟着变动信息和迁移方案
- 关闭github的Issue （Close #254 #233）


example：
```bash
feat($browser): onUrlChange event (popstate/hashchange/polling)

Added new event to $browser:
- forward popstate event if available
- forward hashchange event if popstate not available
- do polling when neither popstate nor hashchange available

Breaks $browser.onHashChange, which was removed (use onUrlChange instead)
```

```bash
fix($compile): couple of unit tests for IE9

Older IEs serialize html uppercased, but IE9 does not...
Would be better to expect case insensitive, unfortunately jasmine does
not allow to user regexps for throw expectations.

Closes #392
Breaks foo.bar api, foo.baz should be used instead
```

```bash
style($location): add couple of missing semi colons
```


工具：Commitizen可以规范git commit的提交记录



#### DOM中的盒模型

offsetWidth、offsetHeight：(width + padding + border)，当element的display为block的时候

clientWidth、clientHeight：(width + padding)，不包括border和scroll bar

scrollWidth、scrollHeight：盒子的实际长度或者宽度，一般而言，当overflow属性为auto的时候，盒子是可以滚动的，这个两个属性包括被隐藏的那一部分，是盒子的实际宽度和高度
![image.png](https://i.loli.net/2020/09/23/6IyagvAcTMCWh3Y.png)


offsetParent：满足下面一个条件的祖先元素
- 具有css定位（position为absolute、relative、fixed、sticky）
- <td> <th> <table>中一个
- <body>

offsetLeft、offsetTop：表示DOM盒模型（offsetHeight、offsetWidth尺寸）和祖先元素的距离信息，**这个是相对距离，如果父元素能够滚动的话，不会随着父元素的滚动而发生变化**

scrollLeft、scrollTop：针对能够滚动的元素而言的（**设置overflow: auto属性的元素，而不是它的子元素**），描述的是元素滚动了多少

clientLeft、clientTop：描述的是border，**如果浏览器的滚动条在左侧的话，clientLeft包含滚动条宽度**


```js
/*
前提：父元素的定位是relative，子元素不包含margin


判断一个可滚动的元素内子元素是否在容器的可视窗口内？
1、子元素整个盒子都进入容器的视口内
2、子元素有一丝空间进入容器视口内部
3、子元素整个盒子都离开容器的视口内
4、子元素有一丝空间离开容器视口内部

变量只有一个： father.scrollTop
常量有三个： child.offsetTop  child.offsetHeight  father.offsetHeight
*/




/*
子元素整个盒子都进入容器的视口内
临界条件: father.scrollTop + father.offsetHeight = child.offsetTop + child.offsetHeight
再向上滚动，scrollTop值增大，child元素就可以视为完全进入了

故条件为father.scrollTop + father.offsetHeight > child.offsetTop + child.offsetHeight

*/
function isChildTotalIn(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const fatherHeight = fatherDOM.offsetHeight;
    const childOffsetTop = child.offsetTop;
    const childHeight = child.offsetHeight;
    return fatherScrollTop > childOffsetTop + childHeight - fatherHeight;
}





/*
子元素有一丝空间进入到父容器的视口
临界条件: father.scrollTop + father.offsetHeight = child.offsetTop
再向上滚动即认为子元素有部分区域进入视口了

father.scrollTop > child.offsetTop - father.offsetHeight
*/

function isChildIn(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const fatherHeight = fatherDOM.offsetHeight;
    return fatherScrollTop > child.offsetTop - fatherHeight;
}



/*
子元素整个盒子都离开父容器的视口
临界条件: father.scrollTop = child.offsetTop + child.offsetHeight


father.scrollTop > child.offsetTop + child.offsetHeight
*/

function isChildTotalOut(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const childOffsetTop = child.offsetTop;
    const childHeight = child.offsetHeight;
    return fatherScrollTop > childOffsetTop + childHeight;
}



/*
子元素整个盒子都进入容器的视口内
临界条件: father.scrollTop = child.offsetTop

故条件为father.scrollTop > child.offsetTop

*/
function isChildOut(child) {
    const fatherDOM = child.offsetParent;
    const fatherScrollTop = fatherDOM.scrollTop;
    const childOffsetTop = child.offsetTop;
    return fatherScrollTop > childOffsetTop;
}
```



#### BFC
BFC表示一块dom区域，影响block box的布局，floats元素和其他元素的交互，当存在下面的属性的时候，BFC context formatting发生
- root element(<html>)
- floats属性不是none
- position为fixed或者absolute
- display:inline-block
- display:table-cell
- display:table-caption
- display:flow-root 这个属性没有任何额外的效果，就是让dom表现为BFC context formatting
- overflow的属性不是visible或者clip
- display: flex的直接子元素
- display: grid的直接子元素


BFC context formatting的作用如下
- 当内部含有float的元素的时候，防止父元素的高度塌陷
- 当block表现为BFC的时候，不会跟float重叠
- 可以避免margin collapsing

具体的demo参考
./css/backup/bfc.html



#### GET、POST请求区别
- get、post在浏览器点击回退都会请求，但是get请求一般是无害的
- get请求的url地址可以被收藏，但是post不可以
- get请求会被浏览器缓存，而post不会，除非被手动设置
- get请求的参数会被完整的保存在浏览器的历史记录里面，post不会
- get、post请求长度http协议并没有限制，get请求的的url长度可能会被浏览器或者服务器端截断，post不会
- get请求参数直接放在url里面，不适合敏感参数的传递，post请求放在Request Body里面




#### 浏览器捕获和冒泡流程
![image.png](https://i.loli.net/2020/11/30/xcil8StjeuPGpTE.png)

window -> window

body -> document.body

html -> document.docmentElement


#### 前端页面的错误监控

- 运行时错误
  - 通过try-catch的方式来捕获错误
  - 通过window.onerror的方式来捕获错误
- 资源加载错误
  - 资源加载错误不会冒泡，不能在冒泡阶段捕获错误，但是可以在捕获阶段监听错误事件
  - Object.onerror事件，在加载图片或者文件的时候发生错误，执行该函数
  - window.addEventListener('Error', function() {}, true) 在捕获阶段可监听错误

上报错误的方式
- ajax(不是主流方式)
- (new Image()).src = 'http://baidu.com/error?name=yu'（简单便捷，不依赖其他库，可以快速上传）


#### dom响应事件中的this
dom中绑定事件有两种方式*addEventListener*和*dom.onclick=function*两种方式
```js
const btnDOM = document.querySelector('.btn');
btnDOM.addEventListener('click', function (e) {
    console.log(this); // btnDOM对象
});
btnDOM.onclick = function (e) {
    console.log(this); // btnDOM对象
};
// 如果绑定的函数是箭头函数，在严格模式下，this是undefined，否则为window（在全局环境下）
// 因为箭头函数没有自己的this，它的this指向了上层函数或者脚本（模块）的this

```


#### html自闭合标签
1.现行html5版本，空标签（void element）br、input可以采用如下两种写法<hr> <hr />对于html5而言，二者没有区别

2.对于外部标签（foreign elements）而言，右斜杠标识了改元素自闭合

3.void elements（area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr）

4.foreign elements（Elements from the MathML namespace and the SVG namespace.）

5.xhtml（严格语法）要求空标签必须自闭合（右斜杠），html5兼容xhtml写法，但是不强制要求自闭合
