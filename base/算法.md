### DP算法

dp算法一般用来解决一些最优化的问题，是运筹学的一个分支。

#### 核心概念

##### 最优子结构
dp问题，一般可以将问题分解为多个子问题，子问题具有相同类似的的结构，通过状态转移方程，能够通过子问题来解决父问题，是一种自底向上解决问题的方法。

core
- 子问题的输出只跟当前的输入有关联，和历史状态无关，确定的输入给出确定的输出
- 子问题的定义实质上是定义如何用某些状态来描述问题，依赖于经验

##### 状态转移函数
如何通过子问题来获得父问题的答案？通过合适的状态转移方程，能够将子问题的最优解转移为父问题的最优解。

##### 用状态来描述问题
一个问题可以从多个角度或者维度去描述，如何用恰当的状态来描述子问题依赖于经验。

core
- 从状态转移方程而言，方程不能涉及过多的历史状态
- 从具体问题分析，该维度定义问题，必须使状态转移方程好描述

#### example

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

定义dp一维数组，dp[i]表示以i为结尾、具有最大和的nums的连续子数组的和。

初始状态：dp[0] = nums[0]

状态转移方程dp[n] = n if dp[n-1] <=0 else n + dp[n-1]

结果：max(dp)


```python
def maxSubArray(self, nums):
    if (len(nums) == 0):
        return 0
    dp = [0 for i in range(len(nums))]
    dp[0] = nums[0]
    for index in range(1, len(nums)):
        sub_question = dp[index - 1]
        if sub_question > 0:
            dp[index] = sub_question + nums[index]
        else:
            dp[index] = nums[index]
    return max(dp)
```
