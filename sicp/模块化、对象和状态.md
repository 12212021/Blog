### 为什么要引进赋值？
构建一个大型的系统一般采用下面的两种方法：
- 将注意放到对象上面来，将一个大型的系统看做是一大批对象的集合，他们之间相互联系，行为随着时间不断地发生变化
- 将注意力放到流过系统的流上面来，非常像一个电子信息工程师在观察一系列的信号流一样

要描述一个对象的是”有状态的“，就需要用一些变量来刻画对象的状态，且该状态受到历史的影响。且对象之间的相互联系是指
对象的状态变量之间建立相互关联。

下面的例子是js描述从一个账户中取钱的过程
```js
let balance = 100;
function withdraw(amount) {
  if (amount > balance) {
    console.log('insuffient funds!');
  } else {
    balance = balance - amount; // 这是赋值，改变了账户的状态变量
    return balance;
  }
}
```

### 引进赋值带来的优势
1、引入赋值使得用状态变量描述随着时间变化的对象变的简单

2、赋值能够让对象在内部自动处理本身随着时间变化的那部分，在一定程度上面对外隐藏了自身的复杂度，使得自身被调用的时候变得简单。

```js
let seedStateful = 8;

// 按照愿望思维的方式
/* 
假设这个函数是一个纯函数，它能够接受一个seed，返回一个数字
多次调用该函数，将产生一个数字序列，该数字序列将存在均匀分布的统计性质
我们可以成这样的数字叫做随机数序列
*/
function updateRandom(toBeUpdate) {}

//判断两个数的最小公约数
function gcd() {}

function randomStateful() {
  let seedStateful = updateRandom(seedStateful); // 赋值
  return seedStateful;
}

function cesaroTest() {
  return 1 === gcd(randomStateful(), randomStateful());
}

// 基于这样的数学原理 6 / pi / pi是随机选取的两个整数之间没有公共因子的概率
function estimatePi(trails) {
  return Math.sqrt(monteCarlo(trails, cesaroTest));
}

// 蒙特卡洛技术是一种在大集合中随机选取实验样本，针对实验结果进行推理的技术
// 下面的这种实现中，使用了stateful的random函数版本
function monteCarlo(trails, experment) {
  const iter = (trailsRemaining, trailsPassed) => {
    if (trailsRemaining === 0) {
      return trailsPassed / trails;
    } else if (experment()) {
      iter(trailsRemaining - 1, trailsPassed + 1);
    } else {
      iter(trailsRemaining - 1, trailsPassed);
    }
  };
  iter(trails, 0);
}

// 如果通过变量来描述对象的状态，那么函数的实现如下

function randomPure(toBeUpdate) {
  return updateRandom(toBeUpdate);
}

function estimatePi(trails, initRandomSeed) {
  return Math.sqrt(monteCarlo(trails, cesaroTest));
}

function cesaroTest(randomVal) {
  const first = randomPure(randomVal);
  const second = randomPure(first);
  return 1 === gcd(first, second);
}

function monteCarlo(trails, experment, initRandomVal) {
  const iter = (trailsRemaining, trailsPassed, randomVal) => {
    if (trailsRemaining === 0) {
      return trailsPassed / trails;
    } else if (experment()) {
      randomVal = randomPure(randomVal);
      iter(trailsRemaining - 1, trailsPassed + 1, randomVal);
    } else {
      randomVal = randomPure(randomVal);
      iter(trailsRemaining - 1, trailsPassed, randomVal);
    }
  };
  iter(trails, 0, 8);
}
```
从上面的例子可以看出，对于随机数的例子而言，当对象不维护自身状态的时候，estimatePi等方法需要维护random函数的状态，但是这些状态对于自身而言并没有价值。
monteCarlo函数维护random的状态不仅仅增加了自身出错的可能性，而且复用变的比较困难。


### 引进赋值带来的问题

#### 函数代换模式的不使用，引入新的环境模型

#### 对象同一和不同问题的思考

#### 时间在程序中的影响

### 流作为延迟计算的表