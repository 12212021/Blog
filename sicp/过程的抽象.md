### 程序设计语言的基本要素
* 基本的表达式 比方2、+、-等
* 组合的方法，能够从比较简答的元素组合成比较复杂的要素 比方： 2+3*7
* 能够对组合方法组合成的复杂对象进行命名，并将这些命名当作一个单元来操作

#### 基础的expression
```js
1+(2+(3+4))
(1+2)+(3+4)
// 涉及到递归运算 +运算符的定义左侧的expr+右侧的expr，而这两个expr也需要进行运算
// 定义：求值组合式的过程需要求值各个子表达式

/* core：
1、数的值就是他们字面表达的值
2、加减乘除对应了ALU能够进行的运算抽象
3、其他名字就是在环境中关联于这一个名字的那个对象
*/
```
#### 命名和环境
```js
var a = 10;
let b = 10;
const c = 10;
function test() {}
class T{}
...
// 这些statement能够在当前的环境中（可以理解为一个大的key-value映射）定义了名字和对象的关联关系
```
#### 过程的定义
```js
function sqrt() {
    //...
}
```
在js中通过function关键子能够定义一个过程，这个定义是在环境中存放了一个函数名->函数代码的映射关系
#### 过程应用的替换模型
```js
function double(x) {
    return 2 * x;
}
double((1 + 2 * 3))

//正则序替换（过程表达式完全展开而后规约）
/*
return 2 * (1 + 2 * 3)
*/
//应用序替换（现求值参数，然后应用）
/*
先对参数进行求值 （1+2*3） -> 7
return 2 * 7
*/
```
在常见的编程语言中，过程的替换模型一般是采用应用序进行替换
#### 过程能够作为黑箱的抽象
过程能够像内置的+、-等运算符一样，只给一个square函数，从表面来看是没有办法区分这个函数是解释器内置的还是自定义的
过程作为黑箱的抽象要求*过程的参数必须相对于该过程是局部的*，也就说下面的两个过程是没有办法区分的
```scheme
(define (square x) (* x x))
(define (square y) (* y y))
(define size 2)
(define (price unit-price) (* size unit-price))
```
过程的参数都局部于该过程，所以参数是*约束变量*， *将一个过程中所有的约束变量约束变量换名，该过程表达的意义不会发生任何改变*
在过程中，一个变量不被约束，则成为*自由变量*，如上述size变量
### 过程以及它们产生的计算
### 用高阶过程做抽象

