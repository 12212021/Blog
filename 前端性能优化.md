## 浏览器性能优化措施

### 采用RAIL来测量网站的性能
- R:Response，在100ms内响应用户的输入
- A:Animation，生成一帧动画需要限制在16ms内，浏览器需要6ms左右，留给js的时间仅仅有10ms
- I:IDLE 保持主线程处于空闲状态，交给主线程执行js的时间要限制在50ms以内
- L:Load页面需要在1s内呈现（框架或者大概），其余的资源可以在后台加载

### Loading Performance

#### 测试页面的性能
- chrome devtools audits面板中的lightHouse工具
- PageSpeed Insights（https://developers.google.com/speed/pagespeed/insights/）
- WebPageTest（https://www.webpagetest.org/）
- Pingdom（https://tools.pingdom.com/）

#### Text Content内容
- 利用webpack、gulp等工具对html、js、css文件进行压缩
- 采用Gzip来压缩文件（对图片等已经压缩过的内容效果很小）
- 如何只采用一些库的几个函数，自己手写，不要引用

#### Graphical Content
- 首先要问一下你自己这些图片是不是需要的
- 选择合适的图片类型，像png的图像视觉效果比jpg要好，尺寸也大一些，但是有时候在网页上，png、jpg类型的图片根本看不出区别
- 有些图片存在一些metadata比方说想作者，拍摄设备等，可以通过（http://www.verexif.com/en/）这样的网站去除照片的metadata
- 裁减图片不必要的地方可以减少图片的尺寸
- 通过一些工具（paint.net）能减少图片的清晰度和尺寸，但是在web page上并不会有明显的区别，需要逐步进行测试
- 一些网站（https://tinypng.com/）能够进一步压缩图片，同时还不影响图片的清晰度

#### HTTP requests
- 将多个分散的css file、js file合并为一个文件，能有效减少http请求的次数，但是要注意*同名css属性、js函数名字覆盖的问题*（HTTP2不要这样）
- 将多个小的图标（icons）合成为一张雪碧图，通过css background position属性展示不同的icone，能有效地节省带宽（HTTP2不要这样）
- js文件的下载会阻塞html页面的渲染，可以将js文件链接存放到body标签的最末
- 直接将js code写在需要操作dom附近的< script >标签内，这样可以避免一次http请求js文件


cache-control控制浏览器缓存（Expires Caching是该字段的一个fallback）
- no-cache：可以缓存，但是每次去服务器验证缓存的数据是否可用
- no-store:不可以缓存，每次都要去服务器请求新的数据
- must-revalidate：如果缓存不过期就继续使用，如果缓存过期之后还想使用该缓存就必须向服务器进行验证
- public：能被浏览器缓存，也能被中间服务器缓存
- private：只能被浏览器缓存，中间设备不能缓存改数据
- max-age：可以缓存的时间，最高可以缓存一年
- （no-cache和no-store、must-revalidate互斥；private和public互斥）


### Rendering Performance


### 网页运行时Performance overview
统共分为Evaluate script、recalculate Style、Layout（reflow）、Paint and composite

Evaluate Script
- 页面交互的handler（js）计算时间长【尽可能让浏览器处理touch、scroll等事件】
- js计算的时间过长【用web Works、requestAnimationFrame】
- 频繁的垃圾回收【看看代码是不是写傻逼了】

Recaculate Style：
- 改变元素几何属性（width、height、position），浏览器要重新生成layout布局
- 非常复杂嵌套的选择器【浏览器花费更长的时间】

Layout：
- 强制同步布局【设置元素的属性之后，再访问元素属性，强制浏览器发生一次布局】
- 同步布局抖动【在循环中不断地重复强制同步布局】

Paint and composite（这个性能问题应该不是很大）